<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Наследование, виртуальные функции - Parallel Programming 2021 Notes</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="course.html"><strong aria-hidden="true">1.</strong> About &amp; Links</a></li><li class="chapter-item expanded "><a href="01_asm.html"><strong aria-hidden="true">2.</strong> Введение в ассемблер</a></li><li class="chapter-item expanded "><a href="02_os_cpu.html"><strong aria-hidden="true">3.</strong> Прерывания, страничная адресация и т.д.</a></li><li class="chapter-item expanded "><a href="03_cache_pipelines.html"><strong aria-hidden="true">4.</strong> Кэши, конвейер</a></li><li class="chapter-item expanded "><a href="04_syntax_types.html"><strong aria-hidden="true">5.</strong> Пересечение синтаксиса C/C++, типы данных</a></li><li class="chapter-item expanded "><a href="05_compilation.html"><strong aria-hidden="true">6.</strong> Этапы компиляции</a></li><li class="chapter-item expanded "><a href="06_classes.html"><strong aria-hidden="true">7.</strong> Классы, абстракция данных</a></li><li class="chapter-item expanded "><a href="07_classes_memory_preprocessor.html"><strong aria-hidden="true">8.</strong> Ещё про классы, выделение памяти, препроцессор</a></li><li class="chapter-item expanded "><a href="08_inheritance.html" class="active"><strong aria-hidden="true">9.</strong> Наследование, виртуальные функции</a></li><li class="chapter-item expanded "><a href="09_exceptions.html"><strong aria-hidden="true">10.</strong> Исключения, гарантии безопасности исключений, RAII</a></li><li class="chapter-item expanded "><a href="10_memory_allocation.html"><strong aria-hidden="true">11.</strong> Механизмы ОС для аллокации памяти, аллокаторы памяти, small-object и copy-on-write оптимизации, статические и динамические библиотеки</a></li><li class="chapter-item expanded "><a href="11_templates.html"><strong aria-hidden="true">12.</strong> Шаблоны (templates)</a></li><li class="chapter-item expanded "><a href="12_stl_sfinae.html"><strong aria-hidden="true">13.</strong> Обзор STL, tag-dispatching, SFINAE, пространства имён</a></li><li class="chapter-item expanded "><a href="13_namespaces_using_adl.html"><strong aria-hidden="true">14.</strong> Пространства имён, using-декларации, using-директивы, ADL</a></li><li class="chapter-item expanded "><a href="14_move_rvalue.html"><strong aria-hidden="true">15.</strong> Move-семантика, rvalue-ссылки</a></li><li class="chapter-item expanded "><a href="15_intrusive_containers.html"><strong aria-hidden="true">16.</strong> Интрузивные контейнеры</a></li><li class="chapter-item expanded "><a href="16_smart_pointers.html"><strong aria-hidden="true">17.</strong> Smart pointers: unique_ptr, shared_ptr, weak_ptr</a></li><li class="chapter-item expanded "><a href="17_perfect_forwarding.html"><strong aria-hidden="true">18.</strong> Perfect forwarding, variadic templates</a></li><li class="chapter-item expanded "><a href="18_decltype_auto_nullptr.html"><strong aria-hidden="true">19.</strong> Decltype, declval, auto, nullptr</a></li><li class="chapter-item expanded "><a href="19_lambdas_type_erasure.html"><strong aria-hidden="true">20.</strong> Анонимные функции, type erasure, std::function</a></li><li class="chapter-item expanded "><a href="20_signals_reetrancy_errors.html"><strong aria-hidden="true">21.</strong> Сигналы, reetrancy, обработки ошибок</a></li><li class="chapter-item expanded "><a href="21_optional_variant_tuple_stringview.html"><strong aria-hidden="true">22.</strong> Optional, variant, tuple, string_view</a></li><li class="chapter-item expanded "><a href="22_constexpr.html"><strong aria-hidden="true">23.</strong> Статическая и динамическая инициализация, constexpr</a></li><li class="chapter-item expanded "><a href="23_multithreading.html"><strong aria-hidden="true">24.</strong> Многопоточность</a></li><li class="chapter-item expanded "><a href="24_qt.html"><strong aria-hidden="true">25.</strong> Qt</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Parallel Programming 2021 Notes</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#Наследование-и-виртуальные-функции" id="Наследование-и-виртуальные-функции">Наследование и виртуальные функции</a></h1>
<ul>
<li><a href="https://www.youtube.com/watch?v=IcAaaX888xc">Запись лекции №1</a></li>
<li><a href="https://www.youtube.com/watch?v=11MKhMYAmnE">Запись лекции №2</a></li>
<li><a href="https://www.youtube.com/watch?v=oMkF60mU8ig">Запись лекции №3</a></li>
<li><a href="https://www.youtube.com/watch?v=0-92_jC7YMU">Запись лекции №4</a></li>
</ul>
<hr />
<pre><code class="language-c++">struct vehicle {
	std::string registration_number;
	void print_name() {
		std::cout &lt;&lt; &quot;vehicle\n&quot;;
	}
};
struct bus : vehicle {	// наследуется от vehicle
	int32_t route_number;
	std::string next_stop() const;
	void print_name() {
		std::cout &lt;&lt; &quot;bus\n&quot;;
	}
};
struct truck : vehicle {
	double cargo_mass;
	void print_name() {
		std::cout &lt;&lt; &quot;truck\n&quot;;
	}
};
void f(vehicle&amp; v){
	v.print_name(); // выведет vehicle, так как статический тип vehicle и при компиляции f подставляется вызов print_name от базового класса
}
int main() {
	bus b;
	vehicle&amp; v = b; // можно делать так
	v.registation_number = &quot;123&quot;;
}
</code></pre>
<p><code>bus</code> содержит и <code>route_number</code>, и <code>registration_number</code>.
Компилятор ищет методы и поля сначала внутри последнего, наследовавшего класса. Поэтому обращение к одинаковым полям класса будет возвращать поле последнего. Если наследуемся от двух классов (в C++ есть множественное наследование) и в двух базовых есть поле/метод с одинаковым названием, а в наследнике нет, то будет ошибка компиляции при обращении от объекта наследника.<br />
Если поля классов совпадают в названии, то обратиться к полю другого можно либо через приведение, либо через <code>classname::field</code>.<br />
Наследующий класс можно приводить к любому наследуемому классу и наоборот.</p>
<p>С методами в наследовании работают точно так же, как и с полями:</p>
<pre><code class="language-c++">struct base {
	void g();
};
struct derived : base {
	void g();
};
int main() {
	derived d;
	d.g(); // запустит g() из derived
	d.base::g(); // запустит g() из base
}
</code></pre>
<p>При создании объектов класса-наследника вызывается дефолтный конструктор базового класса (классы конструируются в порядке от базового к производному, деструкторы наоборот). Если хотим вызывать какой-то определённый конструктор, то можно вызывать его через списки инициализации:</p>
<pre><code class="language-c++">struct bus : vehicle {
	bus(std::string const&amp; registration_number, std::string const&amp; next_stop_name) 
		: vehicle(registration_number),
			next_stop_name(next_stop_name){}
}
</code></pre>
<p>При этом стандарт определяет следующий порядок инициализации <a href="https://en.cppreference.com/w/cpp/language/constructor">перевод с cppreference</a>:</p>
<ul>
<li>Инициализируются виртуальные базовые классы (про них будет потом) in depth-first left-to-right traversal.</li>
<li>Инициализируются прямые базовые классы in left-to-right order.</li>
<li>Инициализируются нестатичные члены класса в порядке их объявления.</li>
</ul>
<p><strong>Как не нужно наследоваться</strong>: если вы не добавляете новых данных, то, возможно, вам не нужно наследование и хватит просто функций.</p>
<h2><a class="header" href="#Виртуальные-функции" id="Виртуальные-функции">Виртуальные функции</a></h2>
<p>Когда без наследования не обойтись? Чаще всего его используют вместе с такими конструкциями, как виртуальные функции. Реализованы они через так называемую таблицу виртуальных функций.</p>
<p>Функции можно пометить кодовым словом <code>virtual</code>. Если пометить в базовом классе, то в производных они тоже будут считаться <code>virtual</code>. Функция <code>virtual</code> вызывается в соответствии с динамическим, а не статическим типом (определяется в рантайме).</p>
<pre><code class="language-c++">struct vehicle {
	virtual void print_name() {
		std::cout &lt;&lt; &quot;vehicle&quot; &lt;&lt; std::endl;
	}
}
struct bus : vehicle {
	void print_name() {
  	std::cout &lt;&lt; &quot;bus&quot; &lt;&lt; std::endl;
  }
}
void f (vehicle&amp; a) {
	a.print_name();
}
int main() {
	bus b;
  b.print_name();
  f(b); // выведет bus, так как print_name виртуальная
}
</code></pre>
<p>Чаще всего для базового класса тяжело разумно определить копирование и присваивание, поэтому помечаем их <code>delete</code>:</p>
<pre><code class="language-c++">int main() {
	bus b;
	vehicle v = b; // что тут происходит? это аналоогично vehicle v = (vehicle&amp;) b; и вызывается конструктор копирования у vehicle
}
</code></pre>
<p>Деструктор базового класса лучше объявлять виртуальным: в таком случае обеспечивается правильное разрушение объектов (чтобы всегда вызывался конструктор производного класса).</p>
<p><strong>Мем</strong>: параметры по умолчанию являются частью декларации, поэтому соответствуют статическому типу, даже если указать другие в наследнике.</p>
<pre><code class="language-c++">#include &lt;string&gt;
#include &lt;iostream&gt;
struct vehicle {
	virtual void print_name(std::string prefix = &quot;Base: &quot;){
		std::cout &lt;&lt; prefix &lt;&lt; &quot;vehicle&quot; &lt;&lt; std::endl;
	}
};
struct bus : vehicle {
	void print_name(std::string prefix = &quot;Derived: &quot;){
		std::cout &lt;&lt; prefix &lt;&lt; &quot;bus&quot; &lt;&lt; std::endl;
	}
};
void bar(vehicle&amp; t){
	t.print_name();
}
int main() {
	bus b;
	b.print_name(); // Derived: bus
	bar(b);	// Base: bus
}
</code></pre>
<h3><a class="header" href="#Про-то-как-это-устроено-внутри" id="Про-то-как-это-устроено-внутри">Про то, как это устроено внутри:</a></h3>
<p>Мы могли бы вместо виртуальных функций делать указатели на функции, но это дорого, так как каждая функция добавляет указатель каждому объекту. Но так как для каждого типа они у нас общие, они хранятся в таблице виртуальных функций, а в объекте хранится указатель на неё.</p>
<p>Из-за этого наличие хотя бы одной виртуальной функции в классе добавляет указатель объектам, а при вызове функции сначала смотрим в таблицу, что обходится дороже и мешает компилятору инлайнить функции.</p>
<h2><a class="header" href="#Абстрактные-методы-и-классы" id="Абстрактные-методы-и-классы">Абстрактные методы (и классы):</a></h2>
<p>Если в классе есть хотя бы одна абстрактная функция (ещё их называют чистыми виртуальными), то класс считается абстрактным и создавать объекты такого типа нельзя.</p>
<pre><code class="language-c++">struct output_device {
	virtual void write(void const* data, size_t size) = 0; // обязательство реализации у наследников
};
struct speakers : output_device {};
struct twitch_stream : output_device {};
struct null_output : output_device {};
</code></pre>
<h2><a class="header" href="#Ещё-немного-про-удаление" id="Ещё-немного-про-удаление">Ещё немного про удаление:</a></h2>
<pre><code class="language-c++">struct base1 {
	int a;
};
struct base2 {
	int b;
};
struct derived : base1, base2 {};
int main () {
	derived* d = new derived();
	base2* b = d;
  delete b; // UB, скорее всего получим ошибку о том, что b - невалидный указатель
}
</code></pre>
<p>Почему ошибка именно такая? Это из-за того, как наследование реализовано внутри: по указателю на <code>derived</code> подряд лежат <code>base1</code> и <code>base2</code> (можно понять, если посмотреть, во что компилируется приведение к ним). По сути, в <code>delete b</code> мы пытаемся освободить не то, что аллоцировали, а то, что лежит по указателю <code>derived+4</code>. </p>
<p>Ещё можно заметить, что приведение ссылок и указателей компилируются по-разному, потому что <code>nullptr</code> после приведения должен оставаться <code>nullptr</code>.</p>
<h2><a class="header" href="#Приведение-типов-cast" id="Приведение-типов-cast">Приведение типов (cast):</a></h2>
<p>Представим, что у нас получился такой код (такое иногда бывает, если части приходят из разных хедеров):</p>
<pre><code class="language-c++">struct base1 {
	int a;
};
struct base2 {
	int b;
};
struct derived;
derived&amp; to_derived(base2&amp; b) {
	return (derived&amp;)b;
}
struct derived : base1, base2 {};
derived&amp; to_derived_2(base2&amp; b) {
	return (derived&amp;)b;
}
</code></pre>
<p>Функции <code>to_derived</code> и <code>to_derived_2</code> скомпилируются в разный код, потому что на момент компиляции <code>to_derived</code> типы <code>base2</code> и <code>derived</code> - несвязанные и Си-шные касты втупую приводят указатели для них без пересчёта сдвигов в памяти.</p>
<p>Как такого избежать (хотя бы словить ошибку)? Использовать C++-style касты:</p>
<pre><code class="language-c++">derived&amp; to_derived(base2&amp; b) {
	return static_cast&lt;derived&amp;&gt;(b); // синтаксис шаблонов
}
</code></pre>
<p>Если это будет написано в том же месте, то словим ошибку компиляции, если после определения <code>derived</code>, то проблем не будет.</p>
<p>Всего есть 4 разных <code>cast</code>:</p>
<ul>
<li>
<p><code>static_cast</code> - то, что нам нужно в 99% случаев. В основном это те касты, которые адекватно прописаны в стандарте: касты чисел, upcast/downcast (в наследовании), T* &lt;-&gt; void*.</p>
</li>
<li>
<p><code>reinterpret_cast</code> - касты, которые зависят от реализации компилятором. Редко бывает полезен, стоит избегать. Например, может приводить указатели к числам.</p>
</li>
<li>
<p><code>const_cast</code> - тоже редко хотим использовать. Например:</p>
</li>
</ul>
<pre><code class="language-c++">int a;
int const&amp; b = a;	// знаем, что ссылка на неконстантный a, но по ней нельзя менять
int&amp; c = const_cast&lt;int&amp;&gt;(b); // &quot;снимает const&quot;, редко нужно, например, если в библиотеке забыли пометить аргумент функции const, а хотим передать что-то константно
</code></pre>
<ul>
<li><code>dynamic_cast</code> - позволяет кастить к указателям и ссылкам на объекты полиморфного типа (которые содержат хотя бы одну виртуальную функцию). Если динамический тип не приводится к тому, к чему кастуем, то <code>nullptr</code> (для ссылок бросит исключение).</li>
</ul>
<pre><code class="language-c++">struct base {
	virtual ~base();
};
struct derived : base {};
void f(base* b) {
	derived* d = dynamic_cast&lt;derived*&gt;(b);
}
</code></pre>
<p>Как это работает внутри? Если посмотреть на код, в который это компилируется, в качестве параметров <code>dynamic_cast</code> передаются <code>type_info</code> для классов. <code>type_info</code> содержит информацию об имени класса и позволяет проверить, одинаковый ли тип у объектов, получить его можнно через <code>typeid(d)</code>. Указатель на <code>type_info</code> хранится в таблице виртуальных функций.</p>
<p><em>В коде редко используют <code>dynamic_cast</code>, потому что чаще всего можно обойтись без него и ещё это может быть дорого</em><br />
Ключ компиляции <code>-fno-rtti</code> отключает хранение рантайм-информации, если хочется сэкономить место в бинарном файле, но это выключает возможность использовать </p>
<h2><a class="header" href="#private-наследование" id="private-наследование">Private наследование</a></h2>
<pre><code class="language-c++">struct output_device {
	virtual void write(void const* data, size_t size) = 0;
	virtual void set_volume(double val) = 0;
	virtual void write(void const* data, size_t size) = 0;
};
struct volume_data : output_device {
	void set_volume(double val) override {
		volume = val;
	}
	double get_volume() override {
		return volume;
	}
private:
	double volume;
}
struct file : volume_data {};
struct speakers : volume_data {};
</code></pre>
<p>В коде выше можно приводить <code>file</code> и <code>speakers</code> к <code>volume_data</code> или использовать указатели на них как указатели на <code>volume_data</code>, чего мы не хотим. Эту проблему решает <code>private</code> наследование:</p>
<pre><code class="language-c++">struct file : private volume_data {}; 
</code></pre>
<p><code>private</code> base класс означает, что мы знаем про наследование только внутри класса. Тогда снаружи нельзя не только приводить, но и вызывать функции родительского класса (если нет <code>override</code> в наследнике).</p>
<p>В этом примере есть проблема - от <code>output_device</code> в таком случае мы тоже наследуемся приватно, так как <code>private</code> &quot;скрывает&quot; непрямые базовые классы тоже. </p>
<p>Часто для использования как выше, можно делать так (например, если у нас независимые аспекты поведения, <em>ну ещё можно менять в рантайме реализацию</em>):</p>
<pre><code class="language-c++">struct widget_painter {
	virtual void paint() = 0;
};
struct widget {
	widget(widget_painter*);
	void set_painter(widget_painter*);
private:
	widget_painter* painter;	// аспекты поведения меняем, передавая разные widget_painter
};
struct mandelbrot_painter : widget_painter {
	void print() override;
};
</code></pre>
<h3><a class="header" href="#protected" id="protected">Protected</a></h3>
<p><code>Protected</code> - модификатор, как <code>public</code> и <code>private</code>, но <code>protected</code> функции можно вызывать только в классах-наследниках.</p>
<h3><a class="header" href="#Мем-про-квадрат-и-прямоугольник" id="Мем-про-квадрат-и-прямоугольник">Мем про квадрат и прямоугольник</a></h3>
<p>Как правильно наследоваться: квадрат от прямоугольника или прямоугольника от квадрата? </p>
<p><del>А никак</del> Это зависит от того, что требуется от интерфейса. В общем случае и то, и то может не подходить (у <code>rectangle</code> разные стороны, у <code>square</code> одинаковые, поэтому могут быть проблемы с сеттерами/геттерами и другими функциями)</p>
<h2><a class="header" href="#virtual-наследование" id="virtual-наследование">Virtual наследование</a></h2>
<p>Если базовый класс помечен <code>virtual</code>, то это значит, что он шарится с другими классами в иерархии. Для иерархии все <code>virtual</code> базы склеиваются в один <code>subobject</code>. Пример:</p>
<pre><code class="language-c++">struct a {
	int x;
	void f() {
		x = 42;
	}
};
struct b : virtual a {};
struct c : virtual a {};
struct d : b, c {};
int main() {
     d dd;
     dd.f(); // не упадёт, как без virtual, так как a общий
}
</code></pre>
<p>Но нельзя в <code>b</code> и <code>c</code> оверрайдить одинаковые виртуальные функции из <code>a</code>, будет ошибка компиляции.</p>
<p>С помощью <code>virtual</code> наследования можно реализовывать часть функций интерфейса:</p>
<pre><code class="language-c++">struct a {
	virtual void f() = 0;
	virtual void g() = 0;
	virtual void h() = 0;
};
struct f_impl : virtual a {
	void f() override;
};
struct g_impl : virtual a {
	void g() override;
};
struct derived : f_impl, g_impl {
	void h() override;
};
</code></pre>
<p>Как хранится виртуальная база? Хранятся указатели на таблицу, в которой оффсеты каждой виртуальной базы.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="07_classes_memory_preprocessor.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="09_exceptions.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="07_classes_memory_preprocessor.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="09_exceptions.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
